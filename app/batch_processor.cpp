#include <iostream>\n#include <filesystem>\n#include <vector>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <fstream>\n#include <regex>\n#include <queue>\n#include <mutex>\n#include <json/json.h>\n\n// Include SDK headers\n#include \"ins_stitcher.h\"\n#include \"ins_common.h\"\n\nnamespace fs = std::filesystem;\n\nstruct ConversionJob {\n    std::string inputPath;\n    std::string outputPath;\n    std::string fileType;\n    std::chrono::system_clock::time_point createdAt;\n};\n\nclass Insta360BatchProcessor {\nprivate:\n    std::string inputDir;\n    std::string outputDir;\n    std::string processedDir;\n    std::string configFile;\n    std::queue<ConversionJob> jobQueue;\n    std::mutex queueMutex;\n    bool running;\n    \n    // Configuration\n    bool enableGPU = false;\n    int outputWidth = 5760;\n    int outputHeight = 2880;\n    int bitrate = 50000000; // 50 Mbps\n    int maxConcurrentJobs = 1;\n    int watchInterval = 30; // seconds\n    \npublic:\n    Insta360BatchProcessor(const std::string& input, const std::string& output, const std::string& processed, const std::string& config) \n        : inputDir(input), outputDir(output), processedDir(processed), configFile(config), running(false) {\n        \n        // Ensure directories exist\n        fs::create_directories(outputDir);\n        fs::create_directories(processedDir);\n        \n        // Load configuration\n        loadConfiguration();\n        \n        // Initialize SDK\n        ins::InitEnv();\n        ins::SetLogLevel(ins::InsLogLevel::INFO);\n        \n        std::cout << \"Insta360 Batch Processor initialized\" << std::endl;\n        std::cout << \"Input directory: \" << inputDir << std::endl;\n        std::cout << \"Output directory: \" << outputDir << std::endl;\n        std::cout << \"Processed directory: \" << processedDir << std::endl;\n    }\n    \n    void loadConfiguration() {\n        if (!fs::exists(configFile)) {\n            createDefaultConfig();\n            return;\n        }\n        \n        try {\n            std::ifstream file(configFile);\n            Json::Value config;\n            file >> config;\n            \n            if (config.isMember(\"enableGPU\")) enableGPU = config[\"enableGPU\"].asBool();\n            if (config.isMember(\"outputWidth\")) outputWidth = config[\"outputWidth\"].asInt();\n            if (config.isMember(\"outputHeight\")) outputHeight = config[\"outputHeight\"].asInt();\n            if (config.isMember(\"bitrate\")) bitrate = config[\"bitrate\"].asInt();\n            if (config.isMember(\"maxConcurrentJobs\")) maxConcurrentJobs = config[\"maxConcurrentJobs\"].asInt();\n            if (config.isMember(\"watchInterval\")) watchInterval = config[\"watchInterval\"].asInt();\n            \n            std::cout << \"Configuration loaded from: \" << configFile << std::endl;\n        } catch (const std::exception& e) {\n            std::cerr << \"Error loading configuration: \" << e.what() << std::endl;\n            std::cerr << \"Using default configuration\" << std::endl;\n        }\n    }\n    \n    void createDefaultConfig() {\n        Json::Value config;\n        config[\"enableGPU\"] = false;\n        config[\"outputWidth\"] = 5760;\n        config[\"outputHeight\"] = 2880;\n        config[\"bitrate\"] = 50000000;\n        config[\"maxConcurrentJobs\"] = 1;\n        config[\"watchInterval\"] = 30;\n        config[\"comment\"] = \"Insta360 Batch Processor Configuration\";\n        \n        std::ofstream file(configFile);\n        file << config;\n        file.close();\n        \n        std::cout << \"Default configuration created: \" << configFile << std::endl;\n    }\n    \n    void scanForFiles() {\n        if (!fs::exists(inputDir)) {\n            std::cerr << \"Input directory does not exist: \" << inputDir << std::endl;\n            return;\n        }\n        \n        try {\n            for (const auto& entry : fs::recursive_directory_iterator(inputDir)) {\n                if (!entry.is_regular_file()) continue;\n                \n                std::string extension = entry.path().extension().string();\n                std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);\n                \n                if (extension == \".insv\" || extension == \".insp\") {\n                    // Check if already processed\n                    std::string relativePath = fs::relative(entry.path(), inputDir).string();\n                    std::string processedPath = (fs::path(processedDir) / relativePath).string();\n                    \n                    if (fs::exists(processedPath)) {\n                        continue; // Already processed\n                    }\n                    \n                    // Create conversion job\n                    ConversionJob job;\n                    job.inputPath = entry.path().string();\n                    job.fileType = extension;\n                    job.createdAt = std::chrono::system_clock::now();\n                    \n                    // Generate output path\n                    std::string outputFileName;\n                    if (extension == \".insv\") {\n                        outputFileName = entry.path().stem().string() + \".mp4\";\n                    } else {\n                        outputFileName = entry.path().stem().string() + \".jpg\";\n                    }\n                    \n                    job.outputPath = (fs::path(outputDir) / outputFileName).string();\n                    \n                    // Add to queue\n                    {\n                        std::lock_guard<std::mutex> lock(queueMutex);\n                        jobQueue.push(job);\n                    }\n                    \n                    std::cout << \"Added to queue: \" << entry.path().filename() << \" (\" << extension << \")\" << std::endl;\n                }\n            }\n        } catch (const std::exception& e) {\n            std::cerr << \"Error scanning directory: \" << e.what() << std::endl;\n        }\n    }\n    \n    bool processVideo(const ConversionJob& job) {\n        std::cout << \"Processing video: \" << fs::path(job.inputPath).filename() << std::endl;\n        \n        try {\n            auto videoStitcher = std::make_shared<ins::VideoStitcher>();\n            \n            std::vector<std::string> inputs = { job.inputPath };\n            videoStitcher->SetInputPath(inputs);\n            videoStitcher->SetOutputPath(job.outputPath);\n            \n            // Configure for NAS environment\n            videoStitcher->EnableCuda(enableGPU);\n            videoStitcher->EnableFlowState(true);\n            videoStitcher->EnableDirectionLock(true);\n            videoStitcher->EnableH265Encoder();\n            videoStitcher->SetOutputBitRate(bitrate);\n            videoStitcher->SetOutputSize(outputWidth, outputHeight);\n            videoStitcher->SetStitchType(ins::STITCH_TYPE::TEMPLATE); // Use template for reliability\n            \n            // Set up progress callback\n            videoStitcher->SetStitchProgressCallback([](int progress, int error) {\n                if (error != 0) {\n                    std::cerr << \"Stitching error: \" << error << std::endl;\n                } else {\n                    std::cout << \"Progress: \" << progress << \"%\" << std::endl;\n                }\n            });\n            \n            videoStitcher->StartStitch();\n            \n            if (fs::exists(job.outputPath)) {\n                std::cout << \"Video conversion completed: \" << fs::path(job.outputPath).filename() << std::endl;\n                return true;\n            } else {\n                std::cerr << \"Video conversion failed - output file not created\" << std::endl;\n                return false;\n            }\n            \n        } catch (const std::exception& e) {\n            std::cerr << \"Error processing video: \" << e.what() << std::endl;\n            return false;\n        }\n    }\n    \n    bool processImage(const ConversionJob& job) {\n        std::cout << \"Processing image: \" << fs::path(job.inputPath).filename() << std::endl;\n        \n        try {\n            auto imageStitcher = std::make_shared<ins::ImageStitcher>();\n            \n            std::vector<std::string> inputs = { job.inputPath };\n            imageStitcher->SetInputPath(inputs);\n            imageStitcher->SetOutputPath(job.outputPath);\n            \n            // Configure for NAS environment\n            imageStitcher->EnableCuda(enableGPU);\n            imageStitcher->SetImageProcessingAccelType(ins::ImageProcessingAccel::kCPU);\n            imageStitcher->SetStitchType(ins::STITCH_TYPE::TEMPLATE);\n            imageStitcher->EnableStitchFusion(false); // Disable to avoid OpenCV issues\n            imageStitcher->SetOutputSize(outputWidth, outputHeight);\n            \n            bool success = imageStitcher->Stitch();\n            \n            if (success && fs::exists(job.outputPath)) {\n                std::cout << \"Image conversion completed: \" << fs::path(job.outputPath).filename() << std::endl;\n                return true;\n            } else {\n                std::cerr << \"Image conversion failed\" << std::endl;\n                return false;\n            }\n            \n        } catch (const std::exception& e) {\n            std::cerr << \"Error processing image: \" << e.what() << std::endl;\n            return false;\n        }\n    }\n    \n    void markAsProcessed(const ConversionJob& job) {\n        try {\n            // Create marker file in processed directory\n            std::string relativePath = fs::relative(job.inputPath, inputDir).string();\n            std::string processedPath = (fs::path(processedDir) / relativePath).string();\n            \n            // Create directory structure\n            fs::create_directories(fs::path(processedPath).parent_path());\n            \n            // Create marker file with metadata\n            std::ofstream markerFile(processedPath);\n            markerFile << \"Processed: \" << std::chrono::system_clock::now().time_since_epoch().count() << std::endl;\n            markerFile << \"Input: \" << job.inputPath << std::endl;\n            markerFile << \"Output: \" << job.outputPath << std::endl;\n            markerFile.close();\n            \n        } catch (const std::exception& e) {\n            std::cerr << \"Error marking as processed: \" << e.what() << std::endl;\n        }\n    }\n    \n    void processJobs() {\n        while (running) {\n            ConversionJob job;\n            bool hasJob = false;\n            \n            {\n                std::lock_guard<std::mutex> lock(queueMutex);\n                if (!jobQueue.empty()) {\n                    job = jobQueue.front();\n                    jobQueue.pop();\n                    hasJob = true;\n                }\n            }\n            \n            if (hasJob) {\n                bool success = false;\n                \n                if (job.fileType == \".insv\") {\n                    success = processVideo(job);\n                } else if (job.fileType == \".insp\") {\n                    success = processImage(job);\n                }\n                \n                if (success) {\n                    markAsProcessed(job);\n                    std::cout << \"Job completed successfully: \" << fs::path(job.inputPath).filename() << std::endl;\n                } else {\n                    std::cerr << \"Job failed: \" << fs::path(job.inputPath).filename() << std::endl;\n                }\n            } else {\n                // No jobs, wait a bit\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n        }\n    }\n    \n    void start() {\n        running = true;\n        std::cout << \"Starting batch processor...\" << std::endl;\n        \n        // Start worker thread\n        std::thread worker(&Insta360BatchProcessor::processJobs, this);\n        \n        // Main loop - scan for new files periodically\n        while (running) {\n            scanForFiles();\n            \n            // Display queue status\n            {\n                std::lock_guard<std::mutex> lock(queueMutex);\n                if (!jobQueue.empty()) {\n                    std::cout << \"Jobs in queue: \" << jobQueue.size() << std::endl;\n                }\n            }\n            \n            // Wait before next scan\n            std::this_thread::sleep_for(std::chrono::seconds(watchInterval));\n        }\n        \n        worker.join();\n    }\n    \n    void stop() {\n        running = false;\n        std::cout << \"Stopping batch processor...\" << std::endl;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    if (argc < 4) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_dir> <output_dir> <processed_dir> [config_file]\" << std::endl;\n        std::cerr << \"Example: \" << argv[0] << \" /data/input /data/output /data/processed /data/config.json\" << std::endl;\n        return 1;\n    }\n    \n    std::string inputDir = argv[1];\n    std::string outputDir = argv[2];\n    std::string processedDir = argv[3];\n    std::string configFile = argc > 4 ? argv[4] : \"/data/config.json\";\n    \n    std::cout << \"Insta360 Batch Processor for Synology NAS\" << std::endl;\n    std::cout << \"==========================================\" << std::endl;\n    \n    try {\n        Insta360BatchProcessor processor(inputDir, outputDir, processedDir, configFile);\n        \n        // Handle shutdown gracefully\n        processor.start();\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Fatal error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}
